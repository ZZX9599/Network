# 计算机网络重点

# 1:概述(了解)

## 1.1:网络

网络是由若干结点和这些节点的链路组成

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314104736166.png" alt="image-20230314104736166" style="zoom: 33%;" />



## 1.2:互联网

多个网络之间**通过路由器**连接起来就构成了一个更大的网络，就叫做互联网【网络的网络】

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314105038654.png" alt="image-20230314105038654" style="zoom: 33%;" />



## 1.3:因特网

因特网是世界最大的互联网，就是数以亿计的网络的网络



## 1.4:ISP

IPS称作为服务的提供者【比如我们接入网络，需要有IP，这些IP是三大运行商去申请的，也是他们提供服务让我们连接到网络的】



<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829085722212.png" alt="image-20220829085722212" style="zoom: 33%;" />

## 1.5:因特网组成

边缘部分：由连接在因特网上的主机组成，用户使用【其实就是我们用户的这些机器】

核心部分：大量的网络和这些路由器组成的，主要是给用户进行服务

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314105525079.png" alt="image-20230314105525079" style="zoom:33%;" />



## 1.6:计算机网络分类

交换技术：电路交换，报文交换，分组交换



覆盖范围：广域网，城域网，局域网，个域网



拓扑结构：总线型，网状型，环形，星型等



## 1.7:计算机网络性能指标

速率：就是传输的速度快慢



带宽：最高数据库，也就是最大的传输速率



吞吐量：单位时间传输数据的数据量



时延：数据量与速度的比值



利用率：整个信道有多少时间是被利用了的



丢包率等：发送的数据的丢失几率







# 2:三种交换方式



## 2.1:电路交换

![image-20230314110136845](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314110136845.png)



第一幅图：数量较少的时候没什么问题

第二幅图：数量很多的时候，如果两两连接，则需要很多的线路

第三幅图：基于这个原因，引入了电话交换机，都先发送到电话交换机上面，然后由这个电话交换机充当中间角色，再进行两个端的连接



通信的步骤：

1：建立连接

2：进行通信

3：释放连接



缺点：两个端连接通信的时候，其他的端一直不能使用，这两个端一直占用资源，不能释放



## 2.2:分组交换

**主机H6发送数据给H2，整个数据称作报文**

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314110315600.png" alt="image-20230314110315600" style="zoom:33%;" />



会把整个报文数据分为若干等分的数据，一部分一部分的发送

但是假设由很多的节点和网络，路由器怎么知道该发送给哪个节点呢？

所以拆分的数据会被带上首部，加上分组的目的地址信息

中间部件收到后解析这个首部，里面含有目的地址，再进行转发

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314110358937.png" alt="image-20230314110358937" style="zoom:33%;" />





目的H2收到之后，去除首部再组合为原始数据

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829091125092.png" alt="image-20220829091125092" style="zoom:50%;" />



**总结：**



发送方：构建分组【带上目的地址和分组首部信息】并发送分组

路由器：缓存分组，转发分组信息

接收方：接收分组，去掉分组首部信息，还原报文



## 2.3:报文交换

与分组交换类似，节点也采用分组转发，但是它的报文不会被拆分成各个小的组成，会把整个报文发送，其余的过程和分组交换是类似的，也是需要中间的节点先存储，再转发，正是因为报文交换的数据是整个报文，所以就要求路由器存在较大的缓存空间，早期使用，现在已经被分组交换所取代



## 2.4:三种方式的对比

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829091625695.png" alt="image-20220829091625695" style="zoom: 50%;" />

电路交换需要建立连接，实时性强，时延小，因为是两个端单独连接，不经过中间件，但是线路占用，效率低



报文交换是交换整个报文，不需要提前连接，但是未分组，需要中间件必须含有大量的缓存空间，存储后自动选择合适的线路来发送数据，大大提高了线路的利用率



分组交换也无需建立连接，线路利用率较高，对报文进行拆分，不需要太大的缓存，分组和传输可以同时进行，能够加速传输，传输出错之后只需要传输出错的部分即可，但是需要额外传输数据，因为增加了分组的首部信息，加上多个分组，可能会引起分组失序问题





# 3:计算机网络体系结构



## 3.1:常见的体系结构



### 1:OSI七层模型

![image-20230314111905345](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314111905345.png)

这个是那些专家提出的模型，是真正的规范模型，但是部分层次之间存在交叉，而且并没有真正的投入使用，所以OSI七层模型只是一个规范，实际上生产的都是四层模型的产品，也就是下面的这个TCP/IP体系结构的产品

### 2:TCP/IP协议

![image-20220829093323048](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829093323048.png)



OSI七层模型实际上只是理论，但实际上实现较为困难，而且有部分相同功能的层重复出现

TCP/IP协议相当于把数据链路层和物理层结合成为网络接口层，去掉了表示层和会话层

**总之：能占领市场的，就是好标准**





个人的计算机一般都包含了TCP/IP的协议族，路由器一般只包含了网际层和网络接口层

因为应用层和运输层会涉及到服务器的应用和端口，然后我们的路由器并不会部署应用

路由器只是进行信息的转发，所以路由器的产品并不需要应用层和运输层



网际层IP协议的作用：

1：和不同的网络接口进行互联

2：在连接网络接口的同时，还可以为运输层提供网络互连服务

3：作为核心协议，承上启下



运输层的作用：

1：在IP提供的服务下，TCP可以给应用层的HTTP和SMTP提供可靠传输服务

2：在IP提供的服务下，UDP可以给应用层的DNS和RTP提供不可靠传输服务



### 3:教学模型

![image-20220829094547556](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829094547556.png)

学习的时候，我们一般使用这种原理体系的五层结构



## 3.2:分层的必要性

![image-20220829094754907](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829094754907.png)

这个很重要，需要先暂时记住他们的作用，便于后面的学习



物理层：也就是传输比特，传输电平的问题

数据链路层：是为了解决在一个网络之间的传输问题【还没有到路由器，属于一个网络内】

网络层：是为了解决在多个网络上面传输的问题【也就是路由器怎么到其他的网络，已经涉及到了多个网络】

运输层：是为了解决进程间的网络通信问题【说白了就是怎么区分端口进程】

应用层：解决多台计算机之间的交互问题【怎么把用户数据打包给运输层】



## 3.3:体系结构专业术语

### 1:实体和对等实体

实体：任何可以发送或者接收信息的硬件或者软件进程

对等实体：再计算机网络中，属于同一层的实体就是对等实体

例如网卡就是一个实体

两台进行通信的计算机的网卡，就可以称作为对等实体

### 2:协议

协议是两个对等实体进行通信的一个规范的

例如应用层协议之间使用 **HTTP，SMTP**

运输层协议使用 **TCP，UDP**

网络层协议使用 **IP**



### 3:服务

我们在使用计算机网络的时候，所有的协议都是针对同一层来讲的，不需要关注下层为我们提供的服务

也就是下层使用什么，我不管，我的协议就只管我们两个同层的实体

服务对上层是透明的，上层只管使用我提供的功能即可，同理，下层的服务我也是只管用



### 4:服务访问点和服务原语

服务访问点：相邻两层的实体交换信息的逻辑接口

- 数据链路层的服务访问点为 **帧**
- 网络层的服务访问点为 **IP协议字段**
- 运输层的服务访问点为 **端口号**



服务原语：就是**上下层**之间进行交互的命令



说白了：

服务访问点：就是**上下层**间相互访问的媒介

服务原语：就是**上下层**之间进行交互的命令



### 5:协议数据单元

协议：同层的

协议数据单元：同层之间进行数据传输和交互的数据单元



### 6:服务数据单元

服务：上下层的

服务数据单元：上下层之间进行数据传输和交互的数据单元

## 3.4:各个层的作用

原理体系结构各层的作用【重点】

物理层：解决传输比特，传输电平的问题

数据链路层：解决在一个网络之间的传输问题【还没有到路由器】

网络层：解决在多个网络上面传输的问题【也就是路由器怎么到其他的网络】

运输层：解决在某个计算机内部之间的进程怎么传输【说白了就是怎么区分端口】

应用层：解决多台计算机之间的交互问题【类似我们的电脑访问百度的服务器】

# 4:输入URL发生了什么

## 4.1:整体图解

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829095313236.png" alt="image-20220829095313236" style="zoom: 50%;" />



## 4.2:主机端

- 基于HTTP协议发送了一个请求，构建一个HTTP报文
- 应用层交付给运输层处理，运输层为其添加TCP首部，形成TCP报文段【该首部主要是区分应用进程，说白了就是区分端口号】
- 运输层交付给网络层处理，网络层为其添加IP首部，形成IP报文段【实现在多个网络传输】
- 网络层交付数据链路层处理，数据链路层为其添加首部尾部，成为帧【为了实现在一段链路或者网络传输】
- 数据链路层交付给物理层，物理层将帧看作是比特流，添加前导码【作用是为了让目的主机做好接收准备】
- 物理层将比特流转换为相应的信号，通过传输媒体到达路由器



## 4.3:路由器

- 路由器的物理层将信号变为比特流，去掉前导码，交付给数据链路层【交付帧】
- 路由器的数据链路层将首部和尾部去掉之后，交付给网络层【交付IP数据报】
- 路由器的网络层解析IP数据报，提取出目的地址，查找自身的路由表，确定转发地址
- 路由器的网络层交付给数据链路层，数据链路层为其添加首部尾部，成为帧【为了实现在一段链路或者网络传输】
- 路由器的数据链路层交付给物理层，物理层将帧看作是比特流，添加前导码【作用是为了让目的主机做好接收准备】



## 4.4:Web服务器

- web服务器的物理层接收到信号，将信号变为比特流，去掉前导码，交付给数据链路层【交付的是帧】
- web服务器的数据链路层接收到帧，去掉首部尾部，交付给网络层【交付IP数据报】
- web服务器的网络层将IP数据报的首部去掉之后，交付给运输层【交付的是TCP报文段】
- web服务器的运输层将TCP报文段的首部去掉之后，交付给应用层【交付的是HTTP请求报文】
- web服务器的应用层进行解析，然后给主机发回HTTP响应报文



**然后再执行响应的操作，和上面的类型，层层封装，层层拆封解析**

![image-20220829101101610](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829101101610.png)







# 5:物理层(了解)

## 5.1:物理层的任务

物理层解决的问题：解决传输比特，传输电平的问题

## 5.2:传输介质(了解)

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829102745188.png" alt="image-20220829102745188" style="zoom:33%;" />

## 5.2:任务和服务可见性

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829102819691.png" alt="image-20220829102819691" style="zoom: 50%;" />

上层不管你下层是怎么做的，你只需要给我提供服务就好了，我不需要知道你怎么做的



# 6:数据链路层

## 6.1:处理的任务

数据链路层是为了解决在一个网络之间的传输问题【这个时候还没有到达路由器】

## 6.2:封装成帧

**对上层【网络层】发送的IP数据报添加帧头和帧尾进行封装成帧**



封装成帧的流程：

1：收到网络层发送的IP数据报

2：对其添加首部和尾部，帧头和帧尾【主要是为了确定比特流中哪一部分是帧】便于数据链路层提取一个个的帧



**如果数据之间也含有相同的帧的话，就不知道哪里是帧的开始了，就会加上帧定界来确定哪里是帧**

**为了提高帧的传输效率，应该让帧的数据部分的长度尽可能要长一点**

## 6.3:差错检测



### 1:问题出现

如果是字节传输

则首部尾部的帧定界字符添加转移字符



也可能是比特错误

比特可能出现错误，1变为0，0变为1

比特怎么解决呢？看下面的解决方案

### 2:奇偶校验(一般不使用)

![image-20220829105709291](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829105709291.png)

### 3:冗余码检验(常用)

![image-20220829105815476](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829105815476.png)

![image-20220829110010408](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829110010408.png)

## 6.4:可靠传输

### 1:两种情况

![image-20220829110229648](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829110229648.png)



![image-20220829110320960](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20220829110320960.png)



### 2:传输差错类型

比特差错只是其中一种类型

还包括：分组丢失，分组失序，分组重复等

## 6.5:可靠传输的实现

### 1:停止等待

停止等待协议的实现如下图所示：

![image-20230314092801971](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314092801971.png)





正确的情况：

发送方每次只能发送一小段数据，到达接收方之后，接收方会反馈ACK给发送方

接收方必须收到了ACK之后，才能发送下一段数据

就这样依次的发送Date，ACK，Date，ACK



误码的情况：

发送方每次只能发送一小段数据，中途误码了，到达接收方之后，接收方会反馈NAK给发送方

接收方收到了NAK之后，重传这段数据



分组丢失的情况：

发送方每次只能发送一小段数据，中途被丢失了，到达不了接收方之后

这样接收方不会做出任何的回应给发送方

这样就造成了发送方的一直等待

所以在发送方设置一个超时时间即可



### 2:回退N帧

![image-20230314094629090](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314094629090.png)



使用的是**滑动窗口**的思想

发送方每次可以发送多个，接收方每次只能一个个的接收



正确情况：

假设发送方发送了0~5的窗口数据给接收方

接收方先接收到0，无误，则接收方的窗口移动到后面一个位置【也就是上面的1】

接收方先接收到1，无误，则接收方的窗口移动到后面一个位置【也就是上面的2】

接收方先接收到2，无误，则接收方的窗口移动到后面一个位置【也就是上面的3】

接收方先接收到3，无误，则接收方的窗口移动到后面一个位置【也就是上面的4】

接收方先接收到4，无误，则接收方的窗口移动到后面一个位置【也就是上面的5】

接收方先接收到5，无误，则接收方的窗口移动到后面一个位置【也就是上面的6】



然后接收方直接返回ACK5给发送方，则表示这一段序列都没问题，并不是收到一个就确认一个





误码情况：

假设还是发送0~5的数据，只有2误码了

接收方先接收到0，无误，则接收方的窗口移动到后面一个位置【也就是上面的1】

接收方先接收到1，无误，则接收方的窗口移动到后面一个位置【也就是上面的2】

发送方发送2，在中途传输过程中误码了，则接收方不会接收，窗口也不移动，发送NAK给发送方



这个时候接收方接收到3，无误，但不会接收，因为窗口没移动【还处于2位置】

这个时候接收方接收到4，无误，但不会接收，因为窗口没移动【还处于2位置】

这个时候接收方接收到5，无误，但不会接收，因为窗口没移动【还处于2位置】



所以发送方会重新传输2~5的数据

接收方先接收到2，无误，则接收方的窗口移动到后面一个位置【也就是上面的3】

接收方先接收到3，无误，则接收方的窗口移动到后面一个位置【也就是上面的4】

接收方先接收到4，无误，则接收方的窗口移动到后面一个位置【也就是上面的5】

接收方先接收到5，无误，则接收方的窗口移动到后面一个位置【也就是上面的6】





所以只要中途的一个误码了，则后面的都需要重新传输，这就是回退N帧名字的由来

### 3:选择重传

![image-20230314094753768](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314094753768.png)

使用的是**滑动窗口**的思想

发送方每次可以发送多个，接收方每次可以多个多个的接收



正确情况：

假设发送方发送了0~5的窗口数据给接收方，接收窗口也是0~5

接收方先接收到0，1，2，3，4，5，经检验无误，则接收方的窗口接收数据

移动到下一个窗口的位置，并反馈ACK给发送方，这个时候窗口的位置就【6，7，0，1，2，3】

发送方继续发送了6~3的窗口数据给接收方，接收窗口6~3接收，然后依次类推



误码情况：

假设发送方发送了0~5的窗口数据给接收方，2误码了，接收窗口是0~5

接收方先接收到数据，经检验序列2误码了，则接收方的窗口接收【0，1，3，4，5】数据

这个时候窗口移动到2这里，红色的代表已经接受的数据

![image-20230314095351619](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314095351619.png)

这个时候返回NAK2，则发送发继续重传2的分组数据

接收到了之后，窗口移动到6位置了，发送ACK，则2号数据接收成功



发送方继续发送了6~3的窗口数据给接收方，接收窗口6~3接收，然后依次类推

## 6.6:点对点协议PPP

![image-20230314103746536](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314103746536.png)

三大运营商先从因特网机构申请一大批的地址

然后用户就可以去三大运行商进行购买，接入网络



PPP是目前最广泛的点对点数据链路层协议【也就是在一个网络间传输，并不是多个网络】

网络间就是【三大运行商安装的信号塔构成的单个网络内】



PPP封装的三大功能：

1：兼容下层物理层传输的数据

2：封装成帧

3：兼容上层的不同的网络协议



### 1:透明传输

也就是如何实现兼容底层的物理层传输，看物理层传输的数据是否存在问题

![image-20230314104334963](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314104334963.png)



也就是把物理层传输的数据封装成帧，帧存在首尾部

数据之中可能含有首尾的数据，我们怎么处理



不管他们用的字节还是比特，我们都进行类似转义的操作即可

字节就插入转义字符

比特就采用填充比特的方式即可



### 2:差错检测

封装成帧的时候，帧尾部含有一个纠错码，验证这个纠错码即可



## 6.7:媒体接入控制(了解)

![image-20230314143428151](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314143428151.png)

共享信道需要解决的内容就是如何协调多个发送和接收站点对一个共享传输媒体的占用问题

也就是信道的复用技术

## 6.8:几种常用的信道复用技术

1：**频分复用(FDM)** ：所有用户在同样的时间占用不同的带宽资源

2：**时分复用（TDM）** ：所有用户在不同的时间占用同样的频带宽度（分时不分频）

3：**统计时分复用 (Statistic TDM)** ：改进的时分复用，能够明显提高信道的利用率

4：**码分复用(CDM)** ： 用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰

这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现

5：**波分复用( WDM)** ：波分复用就是光的频分复用





## 6.9:两地址一协议

### 1:概述

MAC地址是以太网的MAC子层使用的地址【数据链路层】

IP地址是TCP/IP体系结构中网络层所使用的地址【网络层】

ARP协议可以根据IP地址找到MAC地址【网络层】



### 2:MAC地址

![image-20230314144613864](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314144613864.png)

在一个网络中进行传输的时候，如上图所示，发送的时候各个主机都能接收到信息

那么怎么直到这个帧是发送给谁的呢？

我们知道封装成帧的时候需要添加源地址和目的地址

这个地址其实就是MAC地址

假设MAC地址从左到右分别为A，B，C，D，E

则上面的C发送帧的时候，会在帧带上 C【源地址】 和 D【目的地址】

其它的主机接收到之后，发现不是发给自己的，则不会理睬

D接收到之后，发现目的地址的MAC地址是自己，则自己就会接收并解析



MAC地址常被固定在网卡内，所以MAC地址又被称为物理地址

每个网络适配器都有一个全球唯一的MAC标识

而交换机和路由器有更多的网络接口，所以会有更多的MAC地址

严格来说：MAC地址是网络接口的唯一标识【而不是对设备的唯一标识】



主机假设不介入因特网，就在单个网络内使用，则MAC地址足够了

假设需要接入因特网呢？这个时候就需要IP地址了

### 3:IP地址

IP地址是因特网上的主机和路由器所使用的地址【属于网络层的内容】，包含两部分信息

1：网络编号：标识因特网上数以百万的网络

2：主机编号：标识同一个网络上的不同主机

![image-20230314145616469](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314145616469.png)

前面三位属于网络编号。后面的属于主机编号

在同一个网络内的话，则网络编号必须是相同的，后面的用于区分主机





IP地址可以区分这个主机在哪个网络内

然后在这个网络内部，再使用MAC地址就可以找到对应的主机



![image-20230314150205635](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314150205635.png)



主机H1给主机H2发送数据，经历了多个网络，就需要使用IP+MAC

发现在发送的过程中，IP数据报的源地址和目的地址一直没变过

但是在数据链路层的帧里面，帧的源地址和目的地址会层层改变

上面传输的时候，IP地址是已知的，但是MAC地址是不知道的，所以怎么根据IP来确定MAC地址呢？

这个时候就需要使用ARP协议了



### 4:ARP协议

其实，每个主机内都有一个ARP高速缓存

这个缓存内部会记录自己传输的一些主机的IP和MAC地址，如下所示：

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314150700348.png" alt="image-20230314150700348" style="zoom:50%;" />

第一次来的时候，这个缓存怎么构建呢？

![image-20230314145616469](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230314145616469.png)

假设如上图所示：

192.168.61.88 给 192.168.61.64 发送数据

已经知道了IP地址，但是不知道MAC地址，则 192.168.61.88 主机构建不出对应的帧

因为帧里面缺少了目的地的MAC地址



这个时候会发送一个请求去请求 192.168.61.64 主机的MAC地址【所有主机全部都能收到】

所有主机接收到了之后【不是自己的任务，不处理】

当 192.168.61.64 接收到了之后就需要返回响应了

这个时候就把响应返回给 192.168.61.88

这个时候 192.168.61.88 得到了目的地的 MAC 地址了

将上面 192.168.61.64 的MAC地址和IP地址存入ARP缓存

这个时候就可以正确的构建帧了，这个就是ARP协议

## 6.10:虚拟局域网VLAN

以太网交换机工作在`数据链路层`【也包括物理层】

使用一个或者多个以太网交换机互连起来的交换式以太网，其站点都属于同一个广播域

随着交换式以太网的规模扩大，广播域相应的扩大

但是会带来一些问题

1：广播风暴

2：难以管理维护

3：潜在的安全问题



<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230316171459619.png" alt="image-20230316171459619" style="zoom:33%;" />

比如在使用ARP协议根据IP地址来请求MAC地址的时候，就会把请求发给每一个节点



浪费大量的资源和带宽



怎么解决这样的问题呢？首先想到的是采用隔离的思想来实现



使用路由器可以实现广播域的分隔

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230316171826257.png" alt="image-20230316171826257" style="zoom:50%;" />

缺点：路由器的价格十分昂贵



这个时候出现了一种技术叫做VLAN【虚拟局域网技术】



可以将设备划分成多个VLAN区域，或者说是划分为多个网段，节省带宽和资源

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230316172026268.png" alt="image-20230316172026268" style="zoom: 50%;" />



# 7:网络层

## 7.1:处理的任务

主要是处理数据在各个网络间传输的问题【不是单个网络间的传输问题】

单个网络间传递数据是数据链路层【记得区分开来】

要实现网络层的任务，需要解决以下的问题

1：网络层向运输层提供怎么样的服务(可靠传输还是不可靠传输)

2：网络的寻址问题

3：路由的寻址问题

## 7.2:提供的两种服务

### 1:面向连接虚电路的服务

可靠通信由网络来保证

必须建立网络层的连接

属于同一个虚电路的分组均按照同一个路由进行路由转发

当虚电路出现故障，则节点均不能进行通信

总是按照发送顺序到达终点

类似电路交换的实现【只是实现为虚电路】



### 2:无连接的数据报服务

可靠通信依靠用户的主机来保证

不需要进行网络层的连接

每个分组可以走不同的路由

到达终点的时候可能会出现失序，丢失等情况

现在一般就是使用的这种方式，为运输层提供无连接的不可靠传输服务

## 7.3:IPV4地址

IPV4地址就是给因特网上的主机【路由器】的每一个接口分配的在全世界范围内唯一的32位比特的标识符

![image-20230317094112055](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317094112055.png)



IP地址的划分经历了下面的三个阶段

1：分类编址

2：划分子网

3：无分类编址

### 1:分类编址

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317094224490.png" alt="image-20230317094224490" style="zoom:50%;" />

还有D类地址和E类地址，很少涉及，所以暂时不写了



我们以A类地址为例：

A类地址：网络号第一位为0，则还有7位可以进行分配



**问题一：网络号可以分配多少呢？**

注意：

1：网络号全0，不可以指派

2：网络号全1，是默认本地环回地址，也不指派

最小就是 00000001【1】，最大就是 01111110【126】

一共就是`2的7次方 -2 = 126`



**问题二：主机号可以分配多少呢？**

注意：

1：主机号全0，不可以指派

2：主机号全1，是广播地址，也不指派

一共就是`2的24次方 -2`



**范围问题：**

下面的都已经除开了全0和全1的情况，不再赘述

按照8位

A类网络地址开始为0，网络号占1个十进制数，后面7位未知，则划分出来的第一位十进制数在【1~126】

B类网络地址开始为10，网络号占1个十进制数后面6位未知，则划分出来的第一位十进制数在【128~191】

C类网络地址开始为110，后面5位未知，则划分出来的第一位十进制数在【192~223】

也就是说只需要看我们IP地址的第一位即可区分出是哪一位的地址

### 2:划分子网

当某个网络里面的IP地址以及不满足需求的数量的时候，这个适合就引入了子网划分

有一个技术可以用来处理这个子网划分的问题，就叫做子网掩码



子网掩码可以表示IP地址的主机号部分被借用了几个比特来作为子网号

子网掩码使用连续的1来对应网络号和子网号

子网掩码使用连续的0来对应主机号

将划分子网的IPV4地址和对应的子网掩码进行与运算就可以得到IPV4所在子网的网络地址



**案例：**

已知某个网络的地址是218.75.230.0，使用子网掩码255.255.255.128来进行子网划分

划分细节：

- 分析出这是一个C类的网络地址，则前面三位是网络号
- 前面255.255.255.128【表示C类网络地址，最后一位128则表示为 10000000】
- 则从主机地址划分出了一个比特给网络号

也就是如下图所示：

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317111227044.png" alt="image-20230317111227044" style="zoom: 33%;" />

则划分的子网数量：2个

每个子网能分配的地址数：`2的7次方-2 = 126`



划分出来的第一个子网络如下【也就是子网号为0的】

![image-20230317111711733](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317111711733.png)

划分出来的第一个子网络如下【也就是子网号为1的】

![image-20230317111751185](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317111751185.png)



**默认的子网掩码：在未划分子网的情况下使用的子网掩码**

![image-20230317112023650](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317112023650.png)

### 3:无分类编制

这个也叫做斜线记法，也叫做CIDR记法，在IPV4地址后面加上斜线 '/'，在斜线后面写上网络前缀的比特数量

例如：128.14.35.7/20

我们根据这个可以推导出该地址的全部细节

1：地址块的最小地址

2：地址块的最大地址

3：地址块的地址数量

4：地址快聚合的（A类，B类，C类）网络的数量

5：地址掩码（也就是子网掩码）



案例：求128.14.35.7/20地址块的全部细节

![image-20230317113425961](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317113425961.png)



地址数量：【也就是主机号的数量】也就是 2的12次方



地址掩码：跟之前的一样，网络号全部写1，主机号全部写0



上面的这个地址掩码如下所示：

![image-20230317113641226](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317113641226.png)

## 7.4:IP数据报发送和转发

主要包含以下两个部分的内容

1：主机发送IP数据报

2：路由器转发IP数据报



案例分析如下：

![image-20230317140929327](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317140929327.png)

网络地址第一位为192，则为C类地址，前三位十进制数为网络号

子网掩码为：255.255.255.128，则最后一位是 10000000 

则表明从主机号里面分配了一位给网络号

左侧蓝色的是一个子网【路由器左侧是分配到0的子网】

左侧范围是   192.168.0.1  ~   192.168.0.126

右侧黄色的是一个子网【路由器左侧是分配到1的子网】

右侧范围是   192.168.0.129  ~   192.168.0.254



对于左侧的网络，默认网关就是192.168.0.126

对于右侧的网络，默认网关就是192.168.0.254



左右侧各属于一个子网，也就是同一个网络内的，前面三个网络号相同



在同一个网络间进行发送，则不需要进行到路由器，在内部可以直接进行交付

在不同的网络之间进行发送，需要路由器的参与，属于间接交付

![image-20230317141559872](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317141559872.png)

**源主机怎么知道目的主机和自己是不是在同一个网络内？**

判断是否在一个网络内，说白了就是看IP地址的网络号是不是一样的

怎么求网络号？也就是子网掩码和IP地址相与就可以了

![image-20230317141819953](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317141819953.png)

发现IP地址不一样，则不是同一个网络



这个时候把IP数据报转发给路由器



**路由器收到之后怎么把数据转给目标呢？**

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317142446363.png" alt="image-20230317142446363" style="zoom: 50%;" />

路由器的内部含有一个或者多个接口【假设我这儿是两个接口】

则可以连接两个不同的网络

左侧连接的是分配0的子网，右侧连接的是分配1的子网

内部存在一个缓存表

这个时候收到了IP数据包，我们只需要把目的地址的IP和地址掩码想与就可以得到网络号

就把数据转发到对应的网络里面去

然后在另一个网络内找到对应的主机

## 7.5:虚拟专用网VPN

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317150951065.png" alt="image-20230317150951065" style="zoom:33%;" />

这两个都是局域网，没有接入因特网，那么怎么连接呢？

方式一：可以租用专用的通信线路

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317151032073.png" alt="image-20230317151032073" style="zoom:33%;" />

方式二：使用VPN技术

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317151351469.png" alt="image-20230317151351469" style="zoom:33%;" />

两个部门都是私有网络，在因特网之间是没办法进行交流的

所以至少要给两边的私有网络分配一个共有网络

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317151508755.png" alt="image-20230317151508755" style="zoom:33%;" />

左边的私有网络接入了  125.1.2.3 的公网

右边的私有网络接入了  194.4.5.6 的公网



<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317151730741.png" alt="image-20230317151730741" style="zoom: 50%;" />

分析：

发送发构建IP的数据报

发现是发给其他网络的，修改源地址为共有地址

然后对IP数据报进行加密

接收方收到之后进行解密解析出真正发送请求的那台机器的IP地址





一般来说：同一个机构的不同部门的不同网络之间进行的专用网叫做内联网VPN

一个机构需要其他机构参与，则一般会有一个VPN软件，只要接入之后就能连接到

该机构，这个一般叫做远程接入VPN



## 7.6:网络地址转换NAT

这个其实就是内网穿透！

![image-20230317152525019](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230317152525019.png)

我们的主机不接入公网是无法上网的

这个时候其实就是NAT路由器进行的一个IP映射

假设是192.168.0.2发送的请求，实际上被映射到172.38.1.5的公网

实际上NAT路由器就是一个真实公网IP的缓存池

这样就可以实现私人的主机被大家所访问了

但是NAT路由器，价格比较昂贵，因为公网IP是收费的

这个技术也叫做内网穿透技术！

# 8:运输层

## 8.1:处理的任务

物理层，数据链路层，网络层共同解决了主机之间异构的网络所面临的问题

实现了主机到主机之间的通信

但是实际上通信的真正实体是两端主机的进程

实现这一层的主要两个协议就是UDP协议和TCP协议

## 8.2:UDP协议

UDP协议又叫做用户数据报协议，因为它是传输数据报的，不进行拆分

直接把应用层的报文加上UDP首部后直接进行发送

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318165936903.png" alt="image-20230318165936903" style="zoom: 50%;" />

提前不需要建立连接，向应用层提供的是无连接的不可靠传输服务

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318170157120.png" alt="image-20230318170157120" style="zoom:50%;" />

假设出现了异常的情况则不会进行任何的处理，存在丢失的安全问题，但是实现简单

## 8.3:TCP协议

TCP协议需要先建立连接，传输的也不是数据报而是比特流，又叫做传输控制协议

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318170415053.png" alt="image-20230318170415053" style="zoom:50%;" />

对上层提供的是面向连接的可靠传输服务【出现问题会进行补救】

<img src="https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318170519166.png" alt="image-20230318170519166" style="zoom:50%;" />

## 8.4:对比

现在基本上全部都是使用的TCP/IP体系结构，所以重点放在TCP协议上

![image-20230318170654384](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318170654384.png)

## 8.5:TCP流量控制

我们总是希望数据的传输效率越高越好，但是存在多方面的因素，必须要控制流量

所谓的流量控制：就是发送方的速率不要太快了，要让接收方来得及接收数据

TCP协议实现流量控制的办法就是使用  滑动窗口  机制



什么意思？

也就是在建立连接成功了，之后该进行数据传输了

这个时候用户端发送的数据量是受制于接收方的

两边各自有一个窗口的大小

假设接收方的窗口大小为500，则发送方可以发送窗口大小为1 ~ 500 窗口大小内的数据

但是绝对不能超过 500



假设发送方就发送了500窗口大小的数据，接收方全部接受了【不考虑丢失的问题】



当接收方接收到数据之后，会返回消息给发送方进行确认

这个消息会有一些信息，包括下面这些方面

1：是否正确收到消息

2：是否有消息丢失

3：目前的窗口大小【也就是还能接收多少窗口的数据】



发送方接收到确认之后，窗口会移动，假设返回的可用窗口大小是200

则方法方的窗口也会继续拓展200，这200可以继续发送

也就是说：发送方的窗口大小应该小于等于接收方的窗口大小

## 8.6:TCP拥塞控制

在某段时间内，网络中某一资源的需求超过了资源能提供的可用部分，则网络性能就会变差，这就叫作拥塞



假定条件如下：

1：数据单方向传送，另一个方向只是传送确认

2：接收方总存在足够大的缓存空间，因而发送方的窗口大小由网络的拥塞程度来决定



主要存在下面的几种拥塞控制算法

1：慢开始

2：拥塞避免

3：快重传

4：快恢复

![image-20230318182350518](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318182350518.png)



ssthresh叫做门限值【假设初始的门限值设置为16】

在到达门限值之前，发送方的发送速率呈现指数增长，直到到达门限值【这里就是慢开始】

![image-20230318182515453](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318182515453.png)

这个时候就要开始执行拥塞避免算法了

![image-20230318182714444](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318182714444.png)

这个时候不再是指数增加了，而是每次发送的窗口加1来依次增加

假设这个时候出现了网络拥塞【就是数据丢失，触发重传了】

这个时候会把门限值设置为当前值的一半，并把窗口大小调整为1

![image-20230318182913534](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318182913534.png)

这个时候新的门限值为12，窗口大小变为了1【然后由从慢开始算法开始】

![image-20230318183016108](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318183016108.png)

快恢复跟拥塞避免差不了多少，拥塞避免把窗口设置为了1，快恢复把初始的窗口值设置为这个时候窗口的一半

![image-20230318183352597](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318183352597.png)

## 8.7:TCP可靠传输

TCP用字节为单位的滑动窗口来保证可靠传输

![image-20230318183719828](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230318183719828.png)

主要就是依靠发送方和接收方的窗口一致性来保证TCP的可靠传输的

他们的窗口基本上是一直保持一致的

例如上面的31~41发送给了下面，下面的窗口接收到了之后就移动10位，也到42的位置

上面的是正常的情况，主要来看出现问题的情况，看看是怎么进行可靠传输的

先来看几个指针，看看是怎么进行区域的划分的

![image-20230319145044780](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319145044780.png)

这个时候两边的窗口都是20的大小，假设发送方发送10窗口的大小数据，在过程中32，33窗口的数据丢失了

也就是下面的情况

![image-20230319145227629](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319145227629.png)

则32，33窗口的数据不会得到确认，接收方的窗口从31移动到32这里【即使34~41已经接收】

只要存在未接受到数据，则就会在没接收到的窗口前面停止，这个时候发送方的也只能到32窗口

这个时候的窗口就会变成这样

![image-20230319145632574](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319145632574.png)

然后等到时间到了。接收方还没有回应收到32，33窗口的数据，这个时候发送方超时重传32，33数据

然后这个时候31~41的数据全部接收完成，则窗口可以继续移动了

发送方就可以把之前已经发送的数据全部删除了

上面的流程就是TCP的可靠传输的大致模型。也就是依赖窗口滑动来实现的



另外：TCP的通信是全双工通信。每一方都在发送和接收报文段，每一方都有自己的发送窗口和接收窗口

## 8.8:TCP建立连接

上面谈到的都是TCP的数据传输过程，在此之前需要建立连接【也就是大名鼎鼎的三次握手】

TCP的连接建立要解决以下三个问题：
①使TCP双方能够确知对方的存在
②使TCP双方能够协商一些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等) 
③使TCP双方能够对运输实体资源(如缓存大小、连接表中的项目等)进行分配



每一边其实都存在一个监听器，假设左侧是客户端，右侧是服务器端【所以我们在右侧画出监听器】

![image-20230319150351754](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319150351754.png)

1：左侧客户端发起TCP连接的请求【被服务端的监听器监听到】

![image-20230319150522889](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319150522889.png)

2：这个时候服务端会发送一个针对TCP连接请求的确认

![image-20230319150650985](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319150650985.png)

3：这个时候客户端也要发生一个针对TCP连接请求的确认

![image-20230319150800936](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319150800936.png)

最后：这个时候双方已经建立连接成功了，这个时候可以按照窗口的信息进行数据的传输了

![image-20230319150928824](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319150928824.png)

****

面试的问题涉及的更加深入，后面再看吧，反正大概的流程就是这个样子

## 8.9:TCP连接释放

数据传输结束之后，现在就是这个样子，也就是释放连接的初始状态，采用的是4次挥手完成的

![image-20230319151501292](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319151501292.png)

1：客户端发起一个TCP连接释放的报文

![image-20230319151637350](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319151637350.png)

2：服务端发起一个TCP连接释放的普通确认

![image-20230319151735365](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319151735365.png)

3：这个时候会通知服务器关闭对应的服务，在彻底关闭服务之前还是可以进行数据的传递的，等到服务彻底被关闭了之后又会给客户端发起一个TCP的连接释放报文，这个时候是申请真正的关闭了

![image-20230319151914886](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319151914886.png)

4：这个时候客户端发送TCP连接释放的确认报文，服务端收到之后进行最后的确认

![image-20230319152045127](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319152045127.png)

注意：在真正断开连接【进入Close状态】之前。客户端这边还会等待一定的时间才会真正断开连接

是为了出现下面的情况

![image-20230319152310167](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319152310167.png)

# 9:应用层

## 9.1:处理的任务

应用层和传输层非常容易混淆

应用层的主要功能：通过应用程序，将用户操作转换成为服务，并对特定的服务匹配一个相应的服务协议来发送给传输层

简单直白点说，应用层的东西偏向于向用户直接接触，与用户直接交互，为用户提供直接服务，然后把用户想要发送的数据打包给传输层来进行传输



传输层：使源端和目的端机器上的对等实体可以进行会话

在这一层定义了两个端到端的协议：传输控制协议（TCP）和用户数据报协议（UDP）

传输层的主要职责：在源和目标主机的应用程序之间利用端口号来跟踪独立的通信；将应用层发送来的数据分段并进行管理；将这些数据片段重组为完整的应用数据流在终端用户之间执行流量控制；会执行差错恢复，即错误重传； 建立和开始一个会话等



像万维网，域名系统DNS，动态主机DHCP，文件传输FTP等都是应用层的范畴

## 9.2:CS模式

客户/服务器(Client/Server. C/S)方式
客户和服务器是指通信中所涉及的两个应用进程
客户/服务器方式所描述的是进程之间服务和被服务的关
客户是服务请求方，服务器是服务提供方
服务器总是处于运行状态并等待客户的服务请求。服务器具有固定端口号(例如HTTP服务器的默认端口号为80而运行服务器的主机也具有固定的IP地址。

![image-20230319153602475](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319153602475.png)

他们都是出处于网络的边缘部分

C/S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C/S方式
包括万维网WWW、电子邮件、文件传输FTP等。
基于C/S方式的应用服务通常是服务集中型的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上
由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，常会出现服务器计算机跟不上众多客户机请求的情况。为此， 在C/S应用中， 常用计算机群集(或服务器场)构建一个强大的虚拟服务器【集群】

## 9.3:P2P模式

对等(Peer-to-Peer， P2P)方式
口在P2P方式中， 没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等
的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者
目前，在因特网.上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等
基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计
算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于
住宅、校园和办公室中

![image-20230319153853334](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319153853334.png)

说白了，每个人的主机即是一台服务器，也是一个客户端


P2P方式的最突出特性之一 就是它的可扩展性。因为系统每增加一个对等方，不仅增加的是服务的请求
者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低。
P2P方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本，服务提
供商对于将P2P方式用于应用的兴趣越来越大

## 9.4:DHCP协议

![image-20230319154032825](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319154032825.png)

画红色框的主机并没有设置公网IP，这个时候怎么连接外网呢？

很简单自己配置一个就好了，这样就能访问公网了

![image-20230319154147028](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319154147028.png)

但是问题来了，现在我们只需要手动配置两台主机的IP地址，万一有1000台，怎么办？还是手动配置吗

这个时候我们可以安装一台DHCP服务器【可以提前存放某个范围的IP地址，可以给DHCP客户端分配】

在我们的主机上安装DHCP客户端软件，这样我们的主机启动的时候就可以从服务端获取到IP

![image-20230319154402408](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319154402408.png)

这样就可以实现动态的获取IP地址了，现在的主机基本上都有DHCP客户端

## 9.5:DNS解析

![image-20230319154614836](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319154614836.png)

用户不可能来记录IP地址去访问，假设可以出现一个简单好记的东西来代替就好了，这个就出现了域名

域名和IP存在绑定关系，只要申请成功了，则访问域名和访问IP没有任何差别，一模一样

但是域名怎么被解析到IP地址的呢？这个就是DNS服务器的作用了



实际上DNS服务器就可以理解为一个数据库，里面存储的数据就是IP地址和域名的绑定关系，如下：

![image-20230319154915048](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319154915048.png)

所以我们不直接访问IP地址而是访问域名的话，会先看自己的缓存里是不是有记录，没有的话先给DNS服务器发送请求来拿到IP地址，再发送对IP地址的请求，并把这条域名解析记录记录到自己主机的缓存里面去

![image-20230319155106947](https://zzx-note.oss-cn-beijing.aliyuncs.com/wangluo/image-20230319155106947.png)

这样就能够实现域名到IP地址的映射关系了，也就实现了域名访问





为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务
器中广泛地使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。
由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，域名服务器应为每项内容设
置计时器并删除超过合理时间的项(例如，每个项目只存放两天)。
不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器
下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名
时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性